#include <iostream>
#include <chrono>

#include "TiffDownscaling.h"

using std::chrono::high_resolution_clock;
using std::chrono::duration_cast;
using std::chrono::milliseconds;

int main()
{
	/*
	линейная фильтрация - свёртка изображения с матрицой фильтра
	вокруг пикселя берётся матрица с весами, например, 5x5, 
	затем накапливаем сумму произведения. Перемножаем каждый пиксель с весом,
	и суммируем всё в окне. Результат в пиксель картинки. С чётными матрицами
	результат будет смещаться на пол пикселя. Будет нечётная.
	С краевыми пикселями (краевые эффекты) надо дополнять данные.
	Либо дублировать крайние строки и столбцы, либо зеркально отражать картинку.
	Коэффициенты - скользящее среднее. Шаг скольжения 1. Получим рамзытую картинку
	исходных размеров. Если её просто прорядить (взять пиксели), получим то, 
	что раньше было.

	Как вычислять. Для формирования нужно по n строк, одновременно. Перечитывать
	n-1 строк и столбцов не надо. Массив на n строк одномерный, затем, на следующей строке
	0 строка не нужна, надо новую записать поверх 0. Затем поверх 1, поверх 2 и т.д.
	Циклический индекс от 0 до n-1, (i + 1) % n, по нему подгружаем строку в буффер строк

	При свёртке со строками с i-й строкой матрицы умножаем буффер с i + i_0,
	i_0 - смещение, показывающее индекс хранения 1-й строки, и в это i_0 записываем.
	это 1 раз на строку(i + i_0) % n, остаток всего n раз
	i->(i + i_0) % n в буфере
	обновление буфера - вместо i0 грузим следующую строку, и i0 = i0++ % n;
	с учётом смещения обработаем
	I_0 = 0 изначально. Затем цикл по всем строкам буфера
	*/
	try
	{
		auto now = high_resolution_clock::now();

		DownscaleTiffWithAvgScaling(
			"H:\\ImageTest\\0041_0102_01567_1_01497_03_S.tiff",
			"H:\\ImageTest\\filtrationTest.bmp",
			0.01f, 0.99f,
			1);

		auto resultTime = duration_cast<milliseconds>(high_resolution_clock::now() - now);
		std::cout << "Downscaling has been completed in " << resultTime.count() << " ms.\n";
	}
	catch (const std::invalid_argument& e)
	{
		std::cout << e.what() << '\n';
	}
}